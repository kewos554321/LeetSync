# 20. Valid Parentheses

- **連結:** https://leetcode.com/problems/valid-parentheses/
- **標籤:** `String`, `Stack`
- **日期:** 2026-01-12

## 1. 問題理解 (Problem Understanding)
> 給定一個只包含 `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` 的字串，判斷該字串是否有效。
> 有效的條件：
> 1. 左括號必須用相同類型的右括號閉合。
> 2. 左括號必須以正確的順序閉合。
> 3. 每個右括號都有一個對應的相同類型的左括號。
>
> **Constraints:** 字串長度 `1 <= s.length <= 10^4`，字串只包含括號字元。
> **Edge Cases:** 空字串（視為有效）、只有左括號、只有右括號、括號類型不匹配。

## 2. 初步想法 & 暴力解 (Initial Thoughts & Brute-Force)
> 可以反覆掃描字串，每次找到一對相鄰的匹配括號就移除它，直到字串為空（有效）或無法再移除（無效）。
> 時間複雜度是 O(n^2)，空間複雜度是 O(n)。

## 3. 最優解 (Optimal Solution)
> 核心觀念是使用**堆疊 (Stack)**。遇到左括號就入棧，遇到右括號就檢查棧頂是否為對應的左括號。
>
> 演算法步驟：
> 1. 建立一個空的堆疊 `stack`。
> 2. 遍歷字串中的每個字元 `char`。
> 3. 如果 `char` 是左括號 `(`, `[`, `{`，將其推入堆疊。
> 4. 如果 `char` 是右括號：
>    - 檢查堆疊是否為空，若為空則返回 `False`。
>    - 檢查堆疊頂端是否為對應的左括號，若不是則返回 `False`。
>    - 若匹配，則彈出堆疊頂端元素。
> 5. 遍歷結束後，檢查堆疊是否為空。若為空則有效，否則無效。

- **時間複雜度:** O(n)，只需遍歷字串一次。
- **空間複雜度:** O(n)，最壞情況下堆疊會存放所有左括號。

```python
def isValid(s: str) -> bool:
    stack = []
    for char in s:
        if char in '{[(':
            stack.append(char)
        else:
            if not stack:
                return False
            if char == '}' and stack[-1] != '{':
                return False
            if char == ']' and stack[-1] != '[':
                return False
            if char == ')' and stack[-1] != '(':
                return False
            stack.pop()
    return not stack
```

## 4. 關鍵心得 & 延伸 (Key Takeaways & Connections)
> 堆疊是處理「匹配」和「嵌套」結構問題的首選資料結構。當你看到需要追蹤「最近」的某個元素時，堆疊通常是好選擇。
> 可以使用雜湊表來簡化括號匹配的邏輯：`mapping = {')': '(', ']': '[', '}': '{'}`。
> **相關題目:** 22. Generate Parentheses, 32. Longest Valid Parentheses, 150. Evaluate Reverse Polish Notation
