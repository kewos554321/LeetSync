# 121. Best Time to Buy and Sell Stock

- **連結:** https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- **標籤:** `Array`, `Dynamic Programming`, `Greedy`
- **日期:** 2026-01-12

## 1. 問題理解 (Problem Understanding)
> 給定一個陣列 `prices`，其中 `prices[i]` 是股票在第 `i` 天的價格。你想選擇某一天買入股票，並在未來的某一天賣出，以最大化利潤。返回最大利潤，若無法獲利則返回 0。
>
> **Constraints:** 陣列長度 `1 <= prices.length <= 10^5`，價格範圍 `0 <= prices[i] <= 10^4`。
> **Edge Cases:** 只有一天（無法交易）、價格持續下跌（最大利潤為 0）。

## 2. 初步想法 & 暴力解 (Initial Thoughts & Brute-Force)
> 使用兩層迴圈，外層選擇買入日，內層選擇賣出日，計算所有可能的利潤並找最大值。
> 時間複雜度是 O(n^2)，空間複雜度是 O(1)。

```python
def maxProfit_bruteforce(prices):
    max_profit = 0
    for i in range(len(prices)):
        for j in range(i + 1, len(prices)):
            profit = prices[j] - prices[i]
            max_profit = max(max_profit, profit)
    return max_profit
```

## 3. 最優解 (Optimal Solution)
> 核心觀念是**貪心法 (Greedy)**：在遍歷過程中追蹤到目前為止的最低價格，並計算當前價格與最低價格的差值作為潛在利潤。
>
> 演算法步驟：
> 1. 初始化 `min_price` 為無限大，`max_profit` 為 0。
> 2. 遍歷每一天的價格 `price`：
>    - 更新 `min_price = min(min_price, price)`（追蹤到目前為止的最低價）。
>    - 更新 `max_profit = max(max_profit, price - min_price)`（計算若今天賣出的利潤）。
> 3. 返回 `max_profit`。

- **時間複雜度:** O(n)，只需遍歷陣列一次。
- **空間複雜度:** O(1)，只使用常數額外空間。

```python
def maxProfit(prices: List[int]) -> int:
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit
```

## 4. 關鍵心得 & 延伸 (Key Takeaways & Connections)
> 這是一個經典的「單次遍歷追蹤狀態」問題。關鍵洞察是：要最大化利潤，我們需要在最低點買入，所以只需追蹤遍歷過程中的最低價格。
> 這也可以用動態規劃的思維來理解：`dp[i]` 代表前 i 天的最大利潤。
> **相關題目:** 122. Best Time to Buy and Sell Stock II, 123. Best Time to Buy and Sell Stock III, 309. Best Time to Buy and Sell Stock with Cooldown
