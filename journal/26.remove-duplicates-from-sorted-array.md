# 26. Remove Duplicates from Sorted Array

- **連結:** https://leetcode.com/problems/remove-duplicates-from-sorted-array/
- **標籤:** `Array`, `Two Pointers`
- **日期:** 2026-01-12

## 1. 問題理解 (Problem Understanding)
> 給定一個**已排序**的整數陣列 `nums`，原地 (in-place) 移除重複的元素，使每個元素只出現一次，並返回新的長度。不需要考慮陣列中超出新長度後的元素。
>
> **Constraints:** 陣列長度 `1 <= nums.length <= 3 * 10^4`，數字範圍 `-100 <= nums[i] <= 100`，陣列已按升序排列。
> **Edge Cases:** 陣列只有一個元素、所有元素都相同、沒有重複元素。

## 2. 初步想法 & 暴力解 (Initial Thoughts & Brute-Force)
> 可以使用額外的陣列或集合來儲存不重複的元素，但這違反了「原地」的要求。
> 由於陣列已排序，重複元素必定相鄰，這是可以利用的特性。

## 3. 最優解 (Optimal Solution)
> 核心觀念是**雙指針 (Two Pointers)**：一個慢指針 `i` 指向要放置下一個不重複元素的位置，一個快指針 `j` 用來遍歷陣列。
>
> 演算法步驟：
> 1. 初始化慢指針 `i = 0`。
> 2. 使用快指針 `j` 從索引 1 開始遍歷陣列。
> 3. 如果 `nums[j] != nums[i]`（發現新的不重複元素）：
>    - 將 `i` 前進一步。
>    - 將 `nums[j]` 複製到 `nums[i]`。
> 4. 遍歷結束後，返回 `i + 1`（新陣列的長度）。

- **時間複雜度:** O(n)，只需遍歷陣列一次。
- **空間複雜度:** O(1)，原地修改，只使用常數額外空間。

```python
def removeDuplicates(nums: List[int]) -> int:
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```

## 4. 關鍵心得 & 延伸 (Key Takeaways & Connections)
> 雙指針技巧在處理「原地修改已排序陣列」的問題上非常有效。慢指針維護「已處理區域」的邊界，快指針負責探索新元素。
> 記住：已排序陣列中，相同的元素必定相鄰，這大大簡化了重複檢測。
> **相關題目:** 27. Remove Element, 80. Remove Duplicates from Sorted Array II, 283. Move Zeroes
